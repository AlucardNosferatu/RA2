<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ares: Helpers::Alex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ares</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_helpers.html">Helpers</a>      </li>
      <li class="navelem"><a class="el" href="class_helpers_1_1_alex.html">Alex</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Helpers::Alex Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Helpers::Alex" -->
<p><code>#include &lt;src/Utilities/Helpers.Alex.h&gt;</code></p>

<p><a href="class_helpers_1_1_alex-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex_1_1_distinct_collector.html">DistinctCollector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_helpers_1_1_alex_1_1_strict_weak_comparer.html">StrictWeakComparer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default comparer for sets using the lower-than operator.  <a href="struct_helpers_1_1_alex_1_1_strict_weak_comparer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_helpers_1_1_alex_1_1_strict_weak_comparer_3_01_t_00_01typename_01std_1_1enable__if_3_01st04c13cfbd36a484d11a04e55bdaf77b6.html">StrictWeakComparer&lt; T, typename std::enable_if&lt; std::is_base_of&lt; ObjectClass, typename std::remove_pointer&lt; typename T &gt;::type &gt;::value &gt;::type &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized comparer for all objects derived from ObjectClass.  <a href="struct_helpers_1_1_alex_1_1_strict_weak_comparer_3_01_t_00_01typename_01std_1_1enable__if_3_01st04c13cfbd36a484d11a04e55bdaf77b6.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#abcd04535bb1fcd3e68d8de7b8bd22044">getCappedDuration</a> (int CurrentValue, int Duration, int Cap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the new duration a stackable or absolute effect will last.  <a href="#abcd04535bb1fcd3e68d8de7b8bd22044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static DynamicVectorClass<br class="typebreak"/>
&lt; TechnoClass * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#a1bf422e766e7704df99f1c27de3fc6ca">getCellSpreadItems</a> (CoordStruct *coords, float spread, bool includeInAir=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of all units in range of a cell spread weapon.  <a href="#a1bf422e766e7704df99f1c27de3fc6ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a> (CellStruct *cell, int width, int height, std::tr1::function&lt; bool(CellClass *)&gt; action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#a12eb85afff101967f5526ecfed858b54">forEach</a> (CellStruct *cell, float radius, std::tr1::function&lt; bool(CellClass *)&gt; action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#a2c60dd142ea14f19a7380f939e19dd86">forEachCellInRange</a> (CellStruct *cell, float widthOrRange, int height, std::tr1::function&lt; bool(CellClass *)&gt; action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_helpers_1_1_alex.html#ad69cd737926ecea72dc03760164c46bc">forEachObjectInRange</a> (CellStruct *cell, float widthOrRange, int height, std::tr1::function&lt; bool(ObjectClass *)&gt; action)</td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa008b313d765b6f4439a00475aee3f08"></a><!-- doxytag: member="Helpers::Alex::forEach" ref="aa008b313d765b6f4439a00475aee3f08" args="(CellStruct *cell, int width, int height, std::tr1::function&lt; bool(CellClass *)&gt; action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::forEach </td>
          <td>(</td>
          <td class="paramtype">CellStruct *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tr1::function&lt; bool(CellClass *)&gt;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                                                                      {
                        <span class="keywordtype">int</span> ret = 0;

                        <span class="comment">// the coords mark the center of the area</span>
                        CellStruct Offset;
                        Offset.X = (short)(cell-&gt;X - (width / 2));
                        Offset.Y = (short)(cell-&gt;Y - (height / 2));

                        <span class="comment">// take a look at each cell in the rectangle</span>
                        <span class="keywordtype">int</span> cellCount = (width * height);
                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;cellCount; ++i) {

                                <span class="comment">// get the specific cell coordinates</span>
                                CellStruct Cell;
                                Cell.X = (short)(i % width);
                                Cell.Y = (short)(i / width);
                                Cell += Offset;

                                <span class="comment">// get this cell and call the action function</span>
                                CellClass* pCell = MapClass::Instance-&gt;GetCellAt(&amp;Cell);
                                <span class="keywordflow">if</span>(pCell != MapClass::InvalidCell()) {
                                        <span class="keywordflow">if</span>(action(pCell)) {
                                                ++ret;
                                        } <span class="keywordflow">else</span> {
                                                <span class="keywordflow">break</span>;
                                        }
                                }
                        }

                        <span class="keywordflow">return</span> ret;
                }
</pre></div>
</div>
</div>
<a class="anchor" id="a12eb85afff101967f5526ecfed858b54"></a><!-- doxytag: member="Helpers::Alex::forEach" ref="a12eb85afff101967f5526ecfed858b54" args="(CellStruct *cell, float radius, std::tr1::function&lt; bool(CellClass *)&gt; action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::forEach </td>
          <td>(</td>
          <td class="paramtype">CellStruct *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tr1::function&lt; bool(CellClass *)&gt;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                                                             {
                        <span class="keywordtype">int</span> ret = 0;

                        <span class="comment">// radius in every direction</span>
                        <span class="keywordtype">int</span> range = (int)(radius + 0.99) * 2 + 1;

                        <span class="keyword">auto</span> actionIfInRange = [&amp;](CellClass* pCell) -&gt; <span class="keywordtype">bool</span> {
                                <span class="comment">// if it is near enough, do action</span>
                                <span class="keywordflow">if</span>(cell-&gt;DistanceFrom(pCell-&gt;MapCoords) &lt;= radius) {
                                        <span class="keywordflow">if</span>(action(pCell)) {
                                                ++ret;
                                        } <span class="keywordflow">else</span> {
                                                <span class="keywordflow">return</span> <span class="keyword">false</span>;
                                        }
                                }

                                <span class="keywordflow">return</span> <span class="keyword">true</span>;
                        };

                        <span class="comment">// get all cells in a square around the target</span>
                        <a class="code" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a>(cell, range, range, actionIfInRange);

                        <span class="keywordflow">return</span> ret;
                }
</pre></div>
</div>
</div>
<a class="anchor" id="a2c60dd142ea14f19a7380f939e19dd86"></a><!-- doxytag: member="Helpers::Alex::forEachCellInRange" ref="a2c60dd142ea14f19a7380f939e19dd86" args="(CellStruct *cell, float widthOrRange, int height, std::tr1::function&lt; bool(CellClass *)&gt; action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::forEachCellInRange </td>
          <td>(</td>
          <td class="paramtype">CellStruct *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>widthOrRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tr1::function&lt; bool(CellClass *)&gt;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                                                                                          {
                        <span class="keywordflow">if</span>((height &gt; 0) &amp;&amp; ((height * widthOrRange) &gt; 0)) {
                                <span class="comment">// rectangle</span>
                                <span class="keywordflow">return</span> <a class="code" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a>(cell, (<span class="keywordtype">int</span>)widthOrRange, height, action);
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(widthOrRange &gt; 0) {
                                <span class="comment">// circle</span>
                                <span class="keywordflow">return</span> <a class="code" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a>(cell, widthOrRange, action);
                        }
                        <span class="keywordflow">return</span> -1;
                }
</pre></div>
</div>
</div>
<a class="anchor" id="ad69cd737926ecea72dc03760164c46bc"></a><!-- doxytag: member="Helpers::Alex::forEachObjectInRange" ref="ad69cd737926ecea72dc03760164c46bc" args="(CellStruct *cell, float widthOrRange, int height, std::tr1::function&lt; bool(ObjectClass *)&gt; action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::forEachObjectInRange </td>
          <td>(</td>
          <td class="paramtype">CellStruct *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>widthOrRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tr1::function&lt; bool(ObjectClass *)&gt;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                                                                                              {
                        <span class="keywordtype">int</span> ret = 0;

                        <span class="keywordtype">int</span> maxDistance = (int)widthOrRange;

                        <span class="comment">// get target cell cords</span>
                        CoordStruct coords;
                        CellClass* pTarget = MapClass::Instance-&gt;GetCellAt(cell);
                        pTarget-&gt;GetCoords(&amp;coords);

                        <span class="comment">// function to check the exact range</span>
                        <span class="keyword">auto</span> actionIfInRange = [&amp;](CellClass* pCell) -&gt; <span class="keywordtype">bool</span> {

                                <span class="comment">// get the cell contents</span>
                                <span class="keywordflow">for</span>(ObjectClass* pContent = pCell-&gt;GetContent(); pContent; pContent = pContent-&gt;NextObject) {
                                        CoordStruct tmpCoords;
                                        pContent-&gt;GetCoords(&amp;tmpCoords);

                                        <span class="comment">// if it is near enough, do action</span>
                                        <span class="keywordflow">if</span>(coords.DistanceFrom(tmpCoords) &lt;= maxDistance * 256) {
                                                <span class="keywordflow">if</span>(action(pContent)) {
                                                        ++ret;
                                                } <span class="keywordflow">else</span> {
                                                        <span class="keywordflow">return</span> <span class="keyword">false</span>;
                                                }
                                        }                               
                                }

                                <span class="keywordflow">return</span> <span class="keyword">true</span>;
                        };

                        <span class="keywordflow">if</span>((height &gt; 0) &amp;&amp; ((height * (int)widthOrRange) &gt; 0)) {
                                <span class="comment">// rectangle</span>
                                maxDistance += height;
                                <span class="keywordflow">return</span> <a class="code" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a>(cell, (<span class="keywordtype">int</span>)widthOrRange, height, actionIfInRange);
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(widthOrRange &gt; 0) {
                                <span class="comment">// circle, with thick border</span>
                                <span class="keywordflow">return</span> <a class="code" href="class_helpers_1_1_alex.html#aa008b313d765b6f4439a00475aee3f08">forEach</a>(cell, widthOrRange + 1, actionIfInRange);
                        }

                        <span class="keywordflow">return</span> ret;
                }
</pre></div>
</div>
</div>
<a class="anchor" id="abcd04535bb1fcd3e68d8de7b8bd22044"></a><!-- doxytag: member="Helpers::Alex::getCappedDuration" ref="abcd04535bb1fcd3e68d8de7b8bd22044" args="(int CurrentValue, int Duration, int Cap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Helpers::Alex::getCappedDuration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the new duration a stackable or absolute effect will last. </p>
<p>The new frames count is calculated the following way:</p>
<p>If Duration is positive it will inflict damage. If Cap is larger than zero, the maximum amount of frames will be defined by Cap. If the current value already is larger than that, in will not be reduced. If Cap is zero, then the duration can add up infinitely. If Cap is less than zero, duration will be set to Duration, if the current value is not higher already.</p>
<p>If Duration is negative, the effect will be reduced. A negative Cap reduces the current value by Duration. A positive or zero Cap will do the same, but additionally shorten it to Cap if the result would be higher than that. Thus, a Cap of zero removes the current effect altogether.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentValue</td><td>The Technos current remaining time. </td></tr>
    <tr><td class="paramname">Duration</td><td>The duration the effect uses. </td></tr>
    <tr><td class="paramname">Cap</td><td>The maximum Duration this effect can cause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new effect frames count.</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>AlexB </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010-04-27 </dd></dl>
<div class="fragment"><pre class="fragment">                                                                                      {
                        <span class="comment">// Usually, the new duration is just added.</span>
                        <span class="keywordtype">int</span> ProposedDuration = CurrentValue + Duration;

                        <span class="keywordflow">if</span> (Duration &gt; 0) {
                                <span class="comment">// Positive damage.</span>
                                <span class="keywordflow">if</span> (Cap &lt; 0) {
                                        <span class="comment">// Do not stack. Use the maximum value.</span>
                                        <span class="keywordflow">return</span> std::max(Duration, CurrentValue);
                                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cap &gt; 0) {
                                        <span class="comment">// Cap the duration.</span>
                                        <span class="keywordtype">int</span> cappedValue = std::min(ProposedDuration, Cap);
                                        <span class="keywordflow">return</span> std::max(CurrentValue, cappedValue);
                                } <span class="keywordflow">else</span> {
                                        <span class="comment">// There is no cap. Allow the duration to stack up.</span>
                                        <span class="keywordflow">return</span> ProposedDuration;
                                }
                        } <span class="keywordflow">else</span> {
                                <span class="comment">// Negative damage.</span>
                                <span class="keywordflow">return</span> (Cap &lt; 0 ? ProposedDuration : std::min(ProposedDuration, Cap));
                        }
                }
</pre></div>
</div>
</div>
<a class="anchor" id="a1bf422e766e7704df99f1c27de3fc6ca"></a><!-- doxytag: member="Helpers::Alex::getCellSpreadItems" ref="a1bf422e766e7704df99f1c27de3fc6ca" args="(CoordStruct *coords, float spread, bool includeInAir=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static DynamicVectorClass&lt;TechnoClass*&gt;* Helpers::Alex::getCellSpreadItems </td>
          <td>(</td>
          <td class="paramtype">CoordStruct *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeInAir</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a list of all units in range of a cell spread weapon. </p>
<p>CellSpread is handled as described in <a href="http://modenc.renegadeprojects.com/CellSpread.">http://modenc.renegadeprojects.com/CellSpread.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>The location the projectile detonated. </td></tr>
    <tr><td class="paramname">spread</td><td>The range to find items in. </td></tr>
    <tr><td class="paramname">includeInAir</td><td>Include items that are currently InAir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>AlexB </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010-06-28 </dd></dl>
<div class="fragment"><pre class="fragment">                                                                                                                                        {
                        <span class="comment">// set of possibly affected objects. every object can be here only once.</span>
                        <span class="keyword">auto</span> <span class="keyword">set</span> = <span class="keyword">new</span> std::set&lt;TechnoClass*, StrictWeakComparer&lt;ObjectClass*&gt; &gt;();

                        <span class="comment">// the quick way. only look at stuff residing on the very cells we are affecting.</span>
                        CellStruct cellCoords = MapClass::Instance-&gt;GetCellAt(coords)-&gt;MapCoords;
                        <span class="keywordtype">int</span> countCells = CellSpread::NumCells((<span class="keywordtype">int</span>)(spread + 0.99));
                        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; countCells; ++i) {
                                CellStruct tmpCell = CellSpread::GetCell(i);
                                tmpCell += cellCoords;
                                CellClass *c = MapClass::Instance-&gt;GetCellAt(&amp;tmpCell);
                                <span class="keywordflow">for</span>(ObjectClass *curObj = c-&gt;GetContent(); curObj; curObj = curObj-&gt;NextObject) {
                                        <span class="keywordflow">if</span>(TechnoClass *Techno = generic_cast&lt;TechnoClass*&gt;(curObj)) {
                                                <span class="keyword">set</span>-&gt;insert(Techno);
                                        }
                                }
                        }

                        <span class="comment">// flying objects are not included normally</span>
                        <span class="keywordflow">if</span>(includeInAir) {
                                <span class="comment">// the not quite so fast way. skip everything not in the air.</span>
                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;TechnoClass::Array-&gt;Count; ++i) {
                                        TechnoClass *Techno = TechnoClass::Array-&gt;GetItem(i);
                                        <span class="keywordflow">if</span>(Techno-&gt;GetHeight() &gt; 0) {
                                                <span class="comment">// rough estimation</span>
                                                <span class="keywordflow">if</span>(Techno-&gt;Location.DistanceFrom(*coords) &lt;= spread * 256) {
                                                        <span class="keyword">set</span>-&gt;insert(Techno);
                                                }
                                        }
                                }
                        }

                        <span class="comment">// look closer. the final selection. put all affected items in a vector.</span>
                        DynamicVectorClass&lt;TechnoClass*&gt; *ret = <span class="keyword">new</span> DynamicVectorClass&lt;TechnoClass*&gt;();
                        <span class="keywordflow">for</span>(<span class="keyword">auto</span> iterator = set-&gt;begin(); iterator != <span class="keyword">set</span>-&gt;end(); iterator++) {
                                TechnoClass *Techno = *iterator;

                                <span class="comment">// ignore buildings that are not visible, like ambient light posts</span>
                                <span class="keywordflow">if</span>(BuildingTypeClass *BT = specific_cast&lt;BuildingTypeClass*&gt;(Techno-&gt;GetTechnoType())) {
                                        <span class="keywordflow">if</span>(BT-&gt;InvisibleInGame) {
                                                <span class="keywordflow">continue</span>;
                                        }
                                }

                                <span class="comment">// get distance from impact site</span>
                                CoordStruct target;
                                Techno-&gt;GetCoords(&amp;target);
                                <span class="keywordtype">double</span> dist = target.DistanceFrom(*coords);

                                <span class="comment">// reduce the distance for flying aircraft</span>
                                <span class="keywordflow">if</span>((Techno-&gt;WhatAmI() == abs_Aircraft) &amp;&amp; Techno-&gt;IsInAir()) {
                                        dist *= 0.5;
                                }

                                <span class="comment">// this is good</span>
                                <span class="keywordflow">if</span>(dist &lt;= spread * 256) {
                                        ret-&gt;AddItem(Techno);
                                }
                        }

                        <span class="comment">// tidy up</span>
                        <span class="keyword">set</span>-&gt;clear();
                        <span class="keyword">delete</span> <span class="keyword">set</span>;

                        <span class="keywordflow">return</span> ret;
                }
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Utilities/<a class="el" href="_helpers_8_alex_8h.html">Helpers.Alex.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 17 2011 23:42:32 for Ares by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
